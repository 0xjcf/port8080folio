---
description: 
globs: 
alwaysApply: true
---
# Cursor Rule: Avoid `any` Type

## Purpose
To maximize type safety and leverage the full benefits of TypeScript by strictly avoiding the use of the `any` type in application code. Use `unknown` in combination with type guards when the type of a value is genuinely unknown at compile time.

## Rationale
- **Type Safety:** `any` opts out of type checking, effectively reverting to plain JavaScript and losing compile-time error detection. This can lead to unexpected runtime errors.
- **Refactoring Confidence:** Strong types make refactoring safer and easier, as the compiler can verify changes. `any` breaks this contract.
- **Improved Tooling:** Explicit types enable better IntelliSense, autocompletion, and code navigation. `any` hinders these features.
- **Code Clarity:** Using specific types or `unknown` with guards clearly documents the expected shape or the uncertainty of data, improving readability over the ambiguity of `any`.

## Guidelines

### Avoid:

1.  **Using `any` for variables, function parameters, or return types in application code:**
    ```typescript
    // BAD: Loses all type safety
    function processData(data: any): any {
      // No type checking here... errors might occur at runtime
      const result = data.someProperty * 10;
      return result;
    }

    let value: any = getSomeValue();
    value.nonExistentMethod(); // Runtime error, not caught at compile time
    ```

2.  **Using `any` as a type assertion (`as any`) to bypass type errors in application code:** This is often a sign of an underlying type mismatch that should be resolved properly, or a situation where `unknown` is more appropriate.
    ```typescript
    // BAD: Hides a potential type issue
    const element = document.getElementById('my-element') as any;
    element.specificMethod(); // May or may not exist

    // BAD: Bypassing stricter checks
    function handleEvent(event: SomeSpecificEvent) {
        const genericEvent = event as any;
        // ... accessing properties potentially not on SomeSpecificEvent
    }
    ```

### Prefer:

1.  **Specific Types:** Use the most precise type possible.
    ```typescript
    // GOOD: Clear and type-safe
    interface ProcessableData {
        someProperty: number;
    }
    function processData(data: ProcessableData): number {
      const result = data.someProperty * 10;
      return result;
    }

    let value: string | number = getSomeValue();
    ```

2.  **`unknown` with Type Guards:** When a type is truly unknown (e.g., data from an external API before validation, error objects from `catch` blocks), use `unknown` and perform runtime checks using type guards (`typeof`, `instanceof`, custom type guard functions) before operating on the value.
    ```typescript
    // GOOD: Handling unknown data safely
    async function fetchData(url: string): Promise<unknown> {
        const response = await fetch(url);
        return await response.json(); // Returns unknown
    }

    interface ExpectedData { id: number; name: string; }

    // Custom type guard
    function isExpectedData(data: unknown): data is ExpectedData {
      return (
        typeof data === 'object' &&
        data !== null &&
        'id' in data && typeof (data as any).id === 'number' && // Simplified check
        'name' in data && typeof (data as any).name === 'string'
      );
    }

    const result = await fetchData('/api/data');
    if (isExpectedData(result)) {
      // Now TypeScript knows result is ExpectedData
      console.log(result.id, result.name);
    } else {
      console.error("Fetched data is not in the expected format.");
    }

    // GOOD: Handling unknown errors
    try {
      // ... some operation that might throw ...
    } catch (error: unknown) { // Catch as unknown
      let errorMessage = "An unknown error occurred";
      if (error instanceof Error) {
        errorMessage = error.message;
      } else if (typeof error === 'string') {
        errorMessage = error;
      }
      console.error(errorMessage);
    }
    ```

3.  **Generics:** Use generics for functions or types that can operate on a variety of types while maintaining type relationships.

## Exceptions

- **Test Code (Last Resort):** In unit or integration tests, particularly when mocking complex external libraries or dealing with intricate type shapes that are difficult to replicate perfectly, using `any` (especially `as any`) *might* be permissible **as a last resort** if properly justifying it is significantly more complex or provides little value *for that specific test*. **Strongly prefer proper mocking and typing even in tests.** If `any` is used, isolate its use as much as possible.
    ```typescript
    // ACCEPTABLE (if complex mock setup is prohibitive for the test's goal):
    it('should handle complex mock interaction', () => {
        const mockDependency = getMockLibrary();
        // Setup specific mock behavior needed *only* for this test path
        (mockDependency.complexMethod as any).mockReturnValueOnce(/* simplified value */);

        const result = systemUnderTest.useLibrary(mockDependency);

        expect(result).toBe(/* expected result based on simplified mock */);
    });
    ```
- **Third-Party Libraries with Poor Types:** When interacting with JavaScript libraries that lack accurate TypeScript definitions, `any` might be unavoidable temporarily, but consider contributing type definitions or using community-provided `@types` packages if available.

**Prioritize `unknown` over `any` in application code.** Only use `any` when absolutely necessary and document why. Strive for complete type safety.