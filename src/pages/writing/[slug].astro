---
import { getPublishedBlogPosts, type BlogPost } from "../../lib/content/blog";
import BaseLayout from "../../layouts/BaseLayout.astro";
import ProgressSpineTocMobile from "../../components/ProgressSpineTocMobile.astro";
import SubscribeInline from "../../components/SubscribeInline.astro";

export async function getStaticPaths() {
  const posts = await getPublishedBlogPosts();
  return posts.map((post) => ({
    params: { slug: post.slug },
    props: { post },
  }));
}

const { post } = Astro.props as { post: BlogPost };
const { Content, headings } = await post.render();
const title = `${post.data.title} | Jose Flores`;
const description = post.data.description;
const titleSlug = "article-title";
const subscribeVariant = post.data.series
  ? post.data.isSeriesFinal
    ? "seriesComplete"
    : "seriesActive"
  : "generic";
const canonicalUrl = Astro.site
  ? new URL(`/writing/${post.slug}/`, Astro.site).toString()
  : new URL(`/writing/${post.slug}/`, Astro.url).toString();
const blogSchema: Record<string, unknown> = {
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  headline: post.data.title,
  description: post.data.description,
  datePublished: post.data.pubDate.toISOString(),
  author: {
    "@type": "Person",
    name: "Jose Flores",
    url: "https://0xjcf.com",
  },
  mainEntityOfPage: canonicalUrl,
};

if (post.data.updatedDate) {
  blogSchema.dateModified = post.data.updatedDate.toISOString();
}
---

<BaseLayout
  title={title}
  description={description}
  bodyClass="no-js"
  canonical={canonicalUrl}
  ogType="article"
>
  <Fragment slot="head">
    <script
      type="application/ld+json"
      is:inline
      set:html={JSON.stringify(blogSchema)}
    />
    <script defer type="module" src="/scripts/pe.js"></script>
    <script defer type="module" src="/scripts/mermaid-diagrams.js"></script>
  </Fragment>
  <div class="writing-shell section section--writing-page page-content">
    <main id="main" role="main" class="writing-shell__main">
      <div class="container">
        <article class="writing-article" id="writing-article">
          <header>
            <h1 class="section__title" id={titleSlug}>
              {post.data.title}
            </h1>
            <p class="lead writing-article__summary">{post.data.description}</p>
          </header>
          <div class="section__content writing-article__content">
            <Content />
          </div>
          {post.data.glossary?.length ? (
            <section class="writing-glossary" aria-labelledby="glossary-title">
              <h2 id="glossary-title" class="writing-glossary__title">
                Glossary
              </h2>
              <dl class="writing-glossary__list">
                {post.data.glossary.map((entry) => (
                  <div class="writing-glossary__item">
                    <dt class="writing-glossary__term">{entry.term}</dt>
                    <dd class="writing-glossary__definition">
                      {entry.definition}
                    </dd>
                  </div>
                ))}
              </dl>
            </section>
          ) : null}
          <SubscribeInline
            seriesName={post.data.series}
            variant={subscribeVariant}
            formId={`subscribe-${post.slug}`}
          />
        </article>
      </div>
    </main>
    {headings?.length ? (
      <aside class="writing-shell__sidebar" aria-label="Table of contents">
        <nav class="writing-toc" id="writing-toc-panel">
          <div class="writing-toc__header">
            <p class="writing-toc__title">On this page</p>
          </div>
          <ol class="writing-toc__list" id="writing-toc-list" data-toc-scroll="true">
            <li class="writing-toc__item" data-depth="1">
              <a
                class="writing-toc__link"
                href={`#${titleSlug}`}
                data-toc-link={titleSlug}
              >
                {post.data.title}
              </a>
            </li>
            {headings
              .filter((heading) => heading.depth >= 2 && heading.depth <= 3)
              .map((heading) => (
                <li class="writing-toc__item" data-depth={heading.depth}>
                  <a
                    class="writing-toc__link"
                    href={`#${heading.slug}`}
                    data-toc-link={heading.slug}
                  >
                    {heading.text}
                  </a>
                </li>
              ))}
          </ol>
        </nav>
      </aside>
    ) : null}
    {headings?.length ? <ProgressSpineTocMobile client:load /> : null}
  </div>
  <script is:inline type="module">
    (() => {
      const tocList = document.getElementById("writing-toc-list");
      const article = document.getElementById("writing-article");
      const tocScroll = document.querySelector('[data-toc-scroll="true"]');
      if (!tocList || !article || !tocScroll) return;

      const headings = Array.from(
        article.querySelectorAll("h1[id], h2[id], h3[id]"),
      );
      if (!headings.length) return;

      const endSentinel = document.createElement("div");
      endSentinel.dataset.tocEndSentinel = "true";
      endSentinel.setAttribute("aria-hidden", "true");
      endSentinel.style.cssText = "position: relative; width: 100%; height: 1px;";
      article.append(endSentinel);

      let sentinelId = "article-end-sentinel";
      let sentinelCounter = 2;
      while (document.getElementById(sentinelId)) {
        sentinelId = `article-end-sentinel-${sentinelCounter}`;
        sentinelCounter += 1;
      }
      endSentinel.id = sentinelId;

      const endHeading = headings.find(
        (heading) =>
          (heading.textContent || "").trim().toLowerCase() ===
          "series continuation",
      );
      let endId = endHeading?.id;

      if (!endId) {
        let fallbackId = "article-end";
        let endCounter = 2;
        while (document.getElementById(fallbackId)) {
          fallbackId = `article-end-${endCounter}`;
          endCounter += 1;
        }
        endId = fallbackId;

        const endItem = document.createElement("li");
        endItem.className = "writing-toc__item";
        endItem.dataset.depth = "2";
        const endLink = document.createElement("a");
        endLink.className = "writing-toc__link";
        endLink.href = `#${endId}`;
        endLink.dataset.tocLink = endId;
        endLink.textContent = "Series continuation";
        endItem.append(endLink);
        tocList.append(endItem);
      }

      const links = Array.from(tocList.querySelectorAll("[data-toc-link]"));
      if (!links.length) return;
      const tocIds = new Set(
        links.map((link) => link.getAttribute("data-toc-link")).filter(Boolean),
      );
      const tocHeadings = headings.filter((heading) => tocIds.has(heading.id));
      if (!tocHeadings.length) return;

      let activeId = null;
      let isUserInteracting = false;
      let interactionTimeout;

      const setActive = (id) => {
        if (!id || id === activeId) return;
        activeId = id;
        links.forEach((link) => {
          const isActive = link.getAttribute("data-toc-link") === id;
          link.classList.toggle("is-active", isActive);
          if (isActive) {
            link.setAttribute("aria-current", "true");
          } else {
            link.removeAttribute("aria-current");
          }
          link.parentElement?.classList.toggle("is-active", isActive);
        });
        ensureActiveVisible(id);
      };

      const markInteracting = () => {
        isUserInteracting = true;
        if (interactionTimeout) {
          window.clearTimeout(interactionTimeout);
        }
        interactionTimeout = window.setTimeout(() => {
          isUserInteracting = false;
        }, 800);
      };

      tocScroll.addEventListener("mouseenter", () => {
        isUserInteracting = true;
      });
      tocScroll.addEventListener("mouseleave", () => {
        isUserInteracting = false;
      });
      tocScroll.addEventListener("focusin", () => {
        isUserInteracting = true;
      });
      tocScroll.addEventListener("focusout", () => {
        isUserInteracting = false;
      });
      tocScroll.addEventListener("wheel", markInteracting, {
        passive: true,
      });
      tocScroll.addEventListener("touchstart", markInteracting, {
        passive: true,
      });

      const ensureActiveVisible = (id) => {
        if (isUserInteracting) return;
        const link = tocList.querySelector(`a[data-toc-link="${id}"]`);
        if (!link) return;

        const containerRect = tocScroll.getBoundingClientRect();
        const linkRect = link.getBoundingClientRect();

        if (
          linkRect.top >= containerRect.top &&
          linkRect.bottom <= containerRect.bottom
        ) {
          return;
        }

        const containerHeight = containerRect.height;
        let distance = 0;
        if (linkRect.bottom < containerRect.top) {
          distance = containerRect.top - linkRect.bottom;
        } else if (linkRect.top > containerRect.bottom) {
          distance = linkRect.top - containerRect.bottom;
        }

        if (distance > containerHeight) {
          link.scrollIntoView({ block: "center", inline: "nearest", behavior: "smooth" });
        } else {
          link.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
      };

      const isTopLocked = () => window.scrollY <= 80;
      let endIntersecting = false;

      const updateActive = () => {
        if (isTopLocked()) {
          setActive(tocHeadings[0]?.id);
          return;
        }
        const readingLine = window.innerHeight * 0.35;
        const endRect = endSentinel.getBoundingClientRect();
        const endReached = endIntersecting || endRect.top <= readingLine;
        if (endReached) {
          setActive(endId);
          return;
        }
        let current = tocHeadings[0]?.id;
        tocHeadings.forEach((heading) => {
          if (heading.getBoundingClientRect().top <= readingLine) {
            current = heading.id;
          }
        });
        if (current) setActive(current);
      };

      const observer = new IntersectionObserver(
        () => updateActive(),
        {
          root: null,
          threshold: 0,
          rootMargin: "-35% 0px -55% 0px",
        },
      );

      const endObserver = new IntersectionObserver(
        (entries) => {
          endIntersecting = entries.some((entry) => entry.isIntersecting);
          updateActive();
        },
        {
          root: null,
          threshold: 0,
          rootMargin: "-35% 0px -45% 0px",
        },
      );

      tocHeadings.forEach((heading) => observer.observe(heading));
      endObserver.observe(endSentinel);
      updateActive();
      window.addEventListener("scroll", updateActive, { passive: true });
      window.addEventListener("resize", updateActive, { passive: true });
    })();
  </script>
  <script is:inline>
    (() => {
      const toc = document.querySelector(".writing-toc");
      const sidebar = document.querySelector(".writing-shell__sidebar");
      if (!toc || !sidebar) return;

      const mq = window.matchMedia("(min-width: 960px)");
      let rafId;

      const clearFixed = () => {
        toc.classList.remove("is-fixed");
        document.documentElement.style.removeProperty("--toc-fixed-top");
        document.documentElement.style.removeProperty("--toc-fixed-left");
        document.documentElement.style.removeProperty("--toc-fixed-width");
      };

      const applyFixed = () => {
        if (!mq.matches) {
          clearFixed();
          return;
        }

        toc.classList.remove("is-fixed");
        const rect = toc.getBoundingClientRect();
        document.documentElement.style.setProperty(
          "--toc-fixed-top",
          `${rect.top}px`,
        );
        document.documentElement.style.setProperty(
          "--toc-fixed-left",
          `${rect.left}px`,
        );
        document.documentElement.style.setProperty(
          "--toc-fixed-width",
          `${rect.width}px`,
        );
        toc.classList.add("is-fixed");
      };

      const scheduleApply = () => {
        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(() =>
          requestAnimationFrame(applyFixed),
        );
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", scheduleApply, {
          once: true,
        });
      } else {
        scheduleApply();
      }

      mq.addEventListener("change", () => {
        if (mq.matches) {
          scheduleApply();
        } else {
          clearFixed();
        }
      });

      window.addEventListener("resize", scheduleApply, { passive: true });
    })();
  </script>
  <script is:inline>
    (() => {
      const applyLabelStyles = () => {
        const root = document.querySelector(".writing-article");
        if (!root) return;
        const styles = getComputedStyle(document.documentElement);
        const surface =
          styles.getPropertyValue("--color-surface-alt") || "#f5f7fa";
        const text = styles.getPropertyValue("--color-text") || "#111";
        root.querySelectorAll('svg[id^="mermaid-"] .labelBkg').forEach((el) => {
          el.style.backgroundColor = surface;
          el.style.color = text;
          el.style.padding = "2px 6px";
          el.style.borderRadius = "4px";
          el.style.opacity = "1";
        });
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", applyLabelStyles, {
          once: true,
        });
      } else {
        applyLabelStyles();
      }
    })();
  </script>
</BaseLayout>
