<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web Vitals FOUC Detector</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #0f0; }
        .metric { margin: 10px 0; padding: 10px; border: 1px solid #0f0; }
        .bad { color: #f00; border-color: #f00; }
        .good { color: #0f0; }
        .warning { color: #ff0; }
    </style>
</head>
<body>
    <h1>Web Vitals & FOUC Detection</h1>
    <div id="results"></div>
    
    <script type="module">
        import {onCLS, onFID, onLCP, onFCP, onTTFB, onINP} from 'https://unpkg.com/web-vitals@3/dist/web-vitals.js';
        
        const results = document.getElementById('results');
        const metrics = {};
        
        // Detect FOUC by monitoring style changes
        let styleChanges = 0;
        let firstPaintTime = 0;
        
        const observer = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.name === 'first-paint') {
                    firstPaintTime = entry.startTime;
                }
                
                // Track layout shifts (FOUC indicator)
                if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {
                    styleChanges++;
                    console.log('Layout shift detected:', entry.value, 'at', entry.startTime);
                }
            }
        });
        
        observer.observe({ entryTypes: ['paint', 'layout-shift'] });
        
        // Collect Web Vitals
        function addMetric(name, value, rating) {
            metrics[name] = { value, rating };
            updateDisplay();
        }
        
        onCLS((metric) => {
            addMetric('CLS (Layout Shift)', metric.value.toFixed(3), metric.rating);
            if (metric.value > 0.1) {
                addMetric('⚠️ FOUC Detected', `${styleChanges} shifts`, 'bad');
            }
        });
        
        onFCP((metric) => {
            addMetric('FCP (First Contentful Paint)', `${metric.value.toFixed(0)}ms`, metric.rating);
        });
        
        onLCP((metric) => {
            addMetric('LCP (Largest Contentful Paint)', `${metric.value.toFixed(0)}ms`, metric.rating);
        });
        
        onFID((metric) => {
            addMetric('FID (First Input Delay)', `${metric.value.toFixed(0)}ms`, metric.rating);
        });
        
        onTTFB((metric) => {
            addMetric('TTFB (Time to First Byte)', `${metric.value.toFixed(0)}ms`, metric.rating);
        });
        
        onINP((metric) => {
            addMetric('INP (Interaction to Next Paint)', `${metric.value.toFixed(0)}ms`, metric.rating);
        });
        
        // Check for render-blocking resources
        window.addEventListener('load', () => {
            const resources = performance.getEntriesByType('resource');
            const cssFiles = resources.filter(r => r.name.includes('.css'));
            
            cssFiles.forEach(css => {
                const loadTime = css.responseEnd - css.startTime;
                addMetric(`CSS Load Time`, `${loadTime.toFixed(0)}ms`, loadTime > 500 ? 'bad' : 'good');
                
                // Check if CSS loaded after first paint (FOUC indicator)
                if (firstPaintTime && css.responseEnd > firstPaintTime) {
                    addMetric('⚠️ CSS loaded after paint', 'FOUC likely!', 'bad');
                }
            });
            
            // Performance timeline analysis
            const paintEntries = performance.getEntriesByType('paint');
            const fp = paintEntries.find(e => e.name === 'first-paint');
            const fcp = paintEntries.find(e => e.name === 'first-contentful-paint');
            
            if (fp && fcp) {
                const gap = fcp.startTime - fp.startTime;
                addMetric('FP to FCP Gap', `${gap.toFixed(0)}ms`, gap > 100 ? 'warning' : 'good');
                if (gap > 100) {
                    addMetric('⚠️ Style Application Delay', 'Possible FOUC', 'warning');
                }
            }
        });
        
        function updateDisplay() {
            results.innerHTML = Object.entries(metrics)
                .map(([name, data]) => 
                    `<div class="metric ${data.rating}">
                        <strong>${name}:</strong> ${data.value}
                        <span class="rating">[${data.rating}]</span>
                    </div>`
                ).join('');
        }
        
        // Auto-refresh metrics
        setInterval(updateDisplay, 1000);
    </script>
    
    <h2>Test your site:</h2>
    <iframe src="http://localhost:8080" width="100%" height="600" style="border: 2px solid #0f0;"></iframe>
</body>
</html>