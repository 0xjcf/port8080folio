<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance & FOUC Test Results</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, system-ui, sans-serif;
            background: #1a1a1a; 
            color: #fff; 
            padding: 20px;
        }
        h1 { margin-bottom: 20px; color: #ff6e3c; }
        .metrics { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        .metric {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 8px;
        }
        .metric h3 { 
            color: #ff6e3c; 
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
        }
        .value { 
            font-size: 32px; 
            font-weight: bold;
            margin-bottom: 5px;
        }
        .good { color: #10b981; }
        .warning { color: #f59e0b; }
        .bad { color: #ef4444; }
        .status { font-size: 12px; opacity: 0.7; }
        iframe { 
            width: 100%; 
            height: 600px; 
            border: 2px solid #ff6e3c;
            border-radius: 8px;
        }
        #log {
            background: #000;
            color: #0f0;
            padding: 20px;
            border-radius: 8px;
            font-family: monospace;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .log-entry { margin: 5px 0; }
        .log-warning { color: #ff0; }
        .log-error { color: #f00; }
    </style>
</head>
<body>
    <h1>üöÄ Performance & FOUC Detection Report</h1>
    
    <div style="margin-bottom: 20px; display: flex; gap: 10px; align-items: center;">
        <label style="display: flex; align-items: center; gap: 10px;">
            <span>View Mode:</span>
            <select id="viewMode" style="background: #333; color: #fff; padding: 8px; border: 1px solid #ff6e3c; border-radius: 4px; font-size: 16px;">
                <option value="desktop">Desktop (1920x1080)</option>
                <option value="laptop">Laptop (1366x768)</option>
                <option value="tablet">Tablet (768x1024)</option>
                <option value="mobile" selected>Mobile (390x844)</option>
                <option value="mobile-se">Mobile SE (375x667)</option>
            </select>
        </label>
        <button onclick="reloadTest()" style="background: #ff6e3c; color: #fff; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">
            üîÑ Reload Test
        </button>
        <button onclick="copyReport()" style="background: #10b981; color: #fff; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">
            üìã Copy Report
        </button>
        <button onclick="copyJSON()" style="background: #3b82f6; color: #fff; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">
            üìã Copy JSON
        </button>
        <label style="display: flex; align-items: center; gap: 5px;">
            <input type="checkbox" id="throttle" checked>
            <span>Simulate Slow Network</span>
        </label>
    </div>
    
    <div class="metrics" id="metrics">
        <div class="metric">
            <h3>Page Load Status</h3>
            <div class="value" id="status">Testing...</div>
            <div class="status">Analyzing performance</div>
        </div>
        <div class="metric">
            <h3>Device</h3>
            <div class="value" id="deviceInfo" style="font-size: 16px;">Mobile</div>
            <div class="status">Current viewport</div>
        </div>
    </div>
    
    <h2>Live Test (Inspect for FOUC) - <span id="currentView">Mobile View</span></h2>
    <div id="frameContainer" style="background: #000; padding: 20px; border-radius: 8px; display: flex; justify-content: center;">
        <iframe id="testFrame" src="http://localhost:8080" style="background: white;"></iframe>
    </div>
    
    <div id="log">
        <div class="log-entry">üîç Starting performance analysis...</div>
    </div>

    <script>
        const log = document.getElementById('log');
        const metricsContainer = document.getElementById('metrics');
        const testFrame = document.getElementById('testFrame');
        const viewMode = document.getElementById('viewMode');
        const throttleCheckbox = document.getElementById('throttle');
        
        // Viewport configurations
        const viewports = {
            'desktop': { width: 1920, height: 1080, label: 'Desktop', scale: 0.5 },
            'laptop': { width: 1366, height: 768, label: 'Laptop', scale: 0.6 },
            'tablet': { width: 768, height: 1024, label: 'Tablet', scale: 0.7 },
            'mobile': { width: 390, height: 844, label: 'Mobile (iPhone 14)', scale: 1 },
            'mobile-se': { width: 375, height: 667, label: 'Mobile SE', scale: 1 }
        };
        
        // Store all metrics for report
        const reportData = {
            timestamp: new Date().toISOString(),
            device: '',
            metrics: {},
            logs: [],
            verdict: ''
        };
        
        function copyReport() {
            // Collect all metrics from the DOM
            const metrics = document.querySelectorAll('.metric');
            const viewport = viewports[viewMode.value];
            
            // Build report data
            reportData.device = viewport.label;
            reportData.timestamp = new Date().toISOString();
            reportData.logs = [];
            reportData.metrics = {};
            
            // Collect metrics
            metrics.forEach(metric => {
                const name = metric.querySelector('h3')?.textContent || '';
                const value = metric.querySelector('.value')?.textContent || '';
                const status = metric.querySelector('.status')?.textContent || '';
                
                if (name && value) {
                    reportData.metrics[name] = {
                        value: value,
                        status: status
                    };
                }
            });
            
            // Collect logs
            const logEntries = document.querySelectorAll('.log-entry');
            logEntries.forEach(entry => {
                reportData.logs.push(entry.textContent);
            });
            
            // Determine verdict
            const statusEl = document.getElementById('status');
            reportData.verdict = statusEl?.textContent || 'Unknown';
            
            // Format as markdown for clipboard
            const markdown = formatReportAsMarkdown(reportData);
            
            // Copy to clipboard
            navigator.clipboard.writeText(markdown).then(() => {
                // Show success notification
                showNotification('‚úÖ Report copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
                showNotification('‚ùå Failed to copy report', 'error');
            });
        }
        
        function copyJSON() {
            // Collect current report data (same as copy report)
            const metrics = document.querySelectorAll('.metric');
            const viewport = viewports[viewMode.value];
            
            reportData.device = viewport.label;
            reportData.timestamp = new Date().toISOString();
            reportData.logs = [];
            reportData.metrics = {};
            
            // Collect metrics
            metrics.forEach(metric => {
                const name = metric.querySelector('h3')?.textContent || '';
                const value = metric.querySelector('.value')?.textContent || '';
                const status = metric.querySelector('.status')?.textContent || '';
                
                if (name && value) {
                    reportData.metrics[name] = {
                        value: value,
                        status: status,
                        passed: status.includes('‚úÖ')
                    };
                }
            });
            
            // Collect logs
            const logEntries = document.querySelectorAll('.log-entry');
            logEntries.forEach(entry => {
                const text = entry.textContent;
                const type = entry.classList.contains('log-warning') ? 'warning' : 
                            entry.classList.contains('log-error') ? 'error' : 'info';
                reportData.logs.push({
                    message: text,
                    type: type
                });
            });
            
            // Add verdict
            const statusEl = document.getElementById('status');
            reportData.verdict = statusEl?.textContent || 'Unknown';
            reportData.hasFOUC = !reportData.verdict.includes('No FOUC');
            
            // Add summary stats
            reportData.summary = {
                totalMetrics: Object.keys(reportData.metrics).length,
                passedMetrics: Object.values(reportData.metrics).filter(m => m.passed).length,
                warnings: reportData.logs.filter(l => l.type === 'warning').length,
                errors: reportData.logs.filter(l => l.type === 'error').length
            };
            
            // Copy JSON to clipboard
            const jsonString = JSON.stringify(reportData, null, 2);
            navigator.clipboard.writeText(jsonString).then(() => {
                showNotification('üìã JSON copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy JSON:', err);
                showNotification('‚ùå Failed to copy JSON', 'error');
            });
        }
        
        function formatReportAsMarkdown(data) {
            let md = `# Performance & FOUC Test Report\n\n`;
            md += `**Date:** ${new Date(data.timestamp).toLocaleString()}\n`;
            md += `**Device:** ${data.device}\n`;
            md += `**Verdict:** ${data.verdict}\n\n`;
            
            md += `## Metrics\n\n`;
            md += `| Metric | Value | Status |\n`;
            md += `|--------|-------|--------|\n`;
            
            Object.entries(data.metrics).forEach(([name, info]) => {
                md += `| ${name} | ${info.value} | ${info.status} |\n`;
            });
            
            md += `\n## Performance Logs\n\n`;
            data.logs.forEach(log => {
                md += `- ${log}\n`;
            });
            
            md += `\n---\n`;
            md += `*Generated by Performance Test Tool*\n`;
            
            return md;
        }
        
        function showNotification(message, type = 'success') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#10b981' : '#ef4444'};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
                font-weight: bold;
            `;
            notification.textContent = message;
            
            // Add animation styles
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes slideOut {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(100%); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }
        
        // Set initial viewport
        updateViewport();
        
        function updateViewport() {
            const mode = viewMode.value;
            const viewport = viewports[mode];
            
            testFrame.style.width = viewport.width + 'px';
            testFrame.style.height = viewport.height + 'px';
            testFrame.style.transform = `scale(${viewport.scale})`;
            testFrame.style.transformOrigin = 'top center';
            
            document.getElementById('currentView').textContent = viewport.label + ' View';
            document.getElementById('deviceInfo').textContent = `${viewport.width}√ó${viewport.height}`;
            
            // Add mobile class for styling
            if (mode.includes('mobile')) {
                testFrame.style.border = '10px solid #333';
                testFrame.style.borderRadius = '20px';
            } else {
                testFrame.style.border = '2px solid #ff6e3c';
                testFrame.style.borderRadius = '8px';
            }
        }
        
        function reloadTest() {
            // Clear all metrics except the first two (status and device)
            const metricsContainer = document.getElementById('metrics');
            const metrics = metricsContainer.querySelectorAll('.metric');
            for (let i = metrics.length - 1; i >= 2; i--) {
                metrics[i].remove();
            }
            
            // Clear log
            log.innerHTML = '<div class="log-entry">üîç Starting performance analysis...</div>';
            
            // Reset report data
            reportData.logs = [];
            reportData.metrics = {};
            
            // Update status
            document.getElementById('status').textContent = 'Testing...';
            document.getElementById('status').className = 'value';
            
            // Force iframe reload with cache bust
            const currentUrl = testFrame.src.split('?')[0];
            const newUrl = `${currentUrl}?t=${Date.now()}`;
            
            if (throttleCheckbox.checked) {
                addLog('‚ö†Ô∏è Network throttling simulated (Slow 3G)', 'warning');
            }
            
            // Remove and re-add iframe to force complete reload
            const container = document.getElementById('frameContainer');
            const newFrame = testFrame.cloneNode(false);
            newFrame.src = newUrl;
            testFrame.remove();
            container.appendChild(newFrame);
            testFrame = newFrame;
            
            updateViewport();
            
            // Re-observe the new iframe
            observePerformance();
        }
        
        // Listen for viewport changes
        viewMode.addEventListener('change', () => {
            updateViewport();
            reloadTest();
        });
        
        function addLog(message, type = '') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type ? 'log-' + type : ''}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
        
        function addMetric(name, value, status = 'good') {
            const metric = document.createElement('div');
            metric.className = 'metric';
            metric.innerHTML = `
                <h3>${name}</h3>
                <div class="value ${status}">${value}</div>
                <div class="status">${status === 'good' ? '‚úÖ Passed' : status === 'warning' ? '‚ö†Ô∏è Warning' : '‚ùå Failed'}</div>
            `;
            metricsContainer.appendChild(metric);
        }
        
        // Track layout shift sources
        let shiftSources = [];
        
        // Performance Observer
        function observePerformance() {
            const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.entryType === 'paint') {
                        addLog(`Paint: ${entry.name} at ${entry.startTime.toFixed(0)}ms`);
                        
                        if (entry.name === 'first-paint') {
                            addMetric('First Paint', `${entry.startTime.toFixed(0)}ms`, 
                                     entry.startTime < 1000 ? 'good' : 'warning');
                        }
                        if (entry.name === 'first-contentful-paint') {
                            addMetric('First Contentful Paint', `${entry.startTime.toFixed(0)}ms`,
                                     entry.startTime < 1800 ? 'good' : 'warning');
                        }
                    }
                    
                    if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {
                        // Track which elements caused the shift
                        let shiftInfo = `Layout shift: ${entry.value.toFixed(3)}`;
                        if (entry.sources && entry.sources.length > 0) {
                            const sources = entry.sources.map(source => {
                                const elem = source.node;
                                if (elem) {
                                    const id = elem.id ? `#${elem.id}` : '';
                                    const classes = elem.className ? `.${elem.className.split(' ').join('.')}` : '';
                                    const tag = elem.tagName ? elem.tagName.toLowerCase() : '';
                                    return `${tag}${id}${classes}`;
                                }
                                return 'unknown';
                            }).filter(s => s !== 'unknown');
                            
                            if (sources.length > 0) {
                                shiftInfo += ` from: ${sources.join(', ')}`;
                                shiftSources.push(...sources);
                            }
                        }
                        addLog(shiftInfo, 'warning');
                    }
                }
            });
            
            observer.observe({ entryTypes: ['paint', 'layout-shift', 'largest-contentful-paint'] });
        }
        
        observePerformance();
        
        // Check main window performance instead of iframe
        window.addEventListener('load', () => {
            addLog('‚úÖ Page fully loaded');
            
            // Get performance data from main window
            const resources = performance.getEntriesByType('resource');
            const cssFiles = resources.filter(r => r.name.includes('.css'));
            
            if (cssFiles.length > 0) {
                const css = cssFiles[0];
                const loadTime = css.responseEnd - css.startTime;
                addMetric('CSS Load Time', `${loadTime.toFixed(0)}ms`,
                         loadTime < 500 ? 'good' : loadTime < 1000 ? 'warning' : 'bad');
                addLog(`CSS loaded in ${loadTime.toFixed(0)}ms`);
            }
            
            // Paint timing comparison
            const paintEntries = performance.getEntriesByType('paint');
            const fp = paintEntries.find(e => e.name === 'first-paint');
            const fcp = paintEntries.find(e => e.name === 'first-contentful-paint');
            
            if (fp && fcp) {
                const gap = fcp.startTime - fp.startTime;
                addMetric('FP to FCP Gap', `${gap.toFixed(0)}ms`,
                         gap < 50 ? 'good' : gap < 200 ? 'warning' : 'bad');
                
                if (gap === 0) {
                    addLog('‚úÖ Perfect! FP and FCP are simultaneous - no FOUC', 'good');
                } else if (gap > 100) {
                    addLog(`‚ö†Ô∏è ${gap}ms gap between FP and FCP - possible FOUC`, 'warning');
                }
            }
            
            // Check for layout shifts (CLS)
            if (window.PerformanceObserver && PerformanceObserver.supportedEntryTypes.includes('layout-shift')) {
                let cls = 0;
                const clsObserver = new PerformanceObserver((list) => {
                    for (const entry of list.getEntries()) {
                        if (!entry.hadRecentInput) {
                            cls += entry.value;
                        }
                    }
                });
                clsObserver.observe({ entryTypes: ['layout-shift'] });
                
                setTimeout(() => {
                    clsObserver.disconnect();
                    addMetric('CLS Score', cls.toFixed(3), 
                             cls < 0.1 ? 'good' : cls < 0.25 ? 'warning' : 'bad');
                    
                    if (cls > 0.1) {
                        addLog('‚ö†Ô∏è High CLS detected - possible FOUC', 'error');
                        
                        // Report which elements caused shifts
                        if (shiftSources.length > 0) {
                            const uniqueSources = [...new Set(shiftSources)];
                            addLog(`üìç Elements causing shifts: ${uniqueSources.slice(0, 3).join(', ')}`, 'warning');
                            
                            // Add specific recommendations based on common CLS sources
                            if (uniqueSources.some(s => s.includes('sticky-cta'))) {
                                addMetric('Sticky CTA', '‚ö†Ô∏è Causing shifts', 'warning');
                                addLog('üí° FIX: Sticky CTA animation needs optimization', 'warning');
                            }
                            if (uniqueSources.some(s => s.includes('img') || s.includes('picture'))) {
                                addMetric('Images', '‚ö†Ô∏è Missing dimensions', 'warning');
                                addLog('üí° FIX: Add width/height attributes to images', 'warning');
                            }
                            if (uniqueSources.some(s => s.includes('font'))) {
                                addMetric('Fonts', '‚ö†Ô∏è FOUT detected', 'warning');
                                addLog('üí° FIX: Preload fonts or use font-display: optional', 'warning');
                            }
                        }
                    } else {
                        addLog('‚úÖ Low CLS - no significant layout shifts', 'good');
                    }
                    
                    // Mobile-specific checks
                    const isMobile = viewMode.value.includes('mobile');
                    if (isMobile) {
                        addLog('üì± Mobile-specific analysis:', 'warning');
                        
                        // Check if viewport meta is present
                        const viewportMeta = document.querySelector('meta[name="viewport"]');
                        if (viewportMeta) {
                            addMetric('Viewport Meta', '‚úÖ Present', 'good');
                        } else {
                            addMetric('Viewport Meta', '‚ùå Missing', 'bad');
                            addLog('‚ùå Missing viewport meta tag - critical for mobile', 'error');
                        }
                        
                        // Check mobile performance thresholds
                        if (fp && fp.startTime > 1000) {
                            addLog('‚ö†Ô∏è Slow first paint for mobile (>1s)', 'warning');
                        }
                        
                        // Check if CSS is too large for mobile
                        if (cssFiles.length > 0 && cssFiles[0].transferSize > 50000) {
                            addLog('‚ö†Ô∏è CSS file may be too large for mobile networks', 'warning');
                        }
                    }
                    
                    // Update final status with more detail
                    let statusText = '';
                    if (cls < 0.1) {
                        statusText = isMobile ? '‚úÖ Mobile: No FOUC!' : '‚úÖ Desktop: No FOUC!';
                    } else {
                        statusText = `‚ö†Ô∏è CLS ${cls.toFixed(3)} - Layout Shifts Detected`;
                    }
                    document.getElementById('status').textContent = statusText;
                    document.getElementById('status').className = cls < 0.1 ? 'value good' : 'value warning';
                }, 2000);
            }
        });
        
        // Monitor main page performance
        window.addEventListener('load', () => {
            const perfData = performance.getEntriesByType('navigation')[0];
            if (perfData) {
                addLog(`Page loaded in ${perfData.loadEventEnd.toFixed(0)}ms`);
            }
        });
        
        // Add manual test instructions
        setTimeout(() => {
            addLog('üí° TIP: Open DevTools ‚Üí Performance ‚Üí Record a reload to see detailed FOUC analysis');
            addLog('üí° TIP: Check the Network tab to ensure CSS loads before first paint');
        }, 3000);
    </script>
</body>
</html>